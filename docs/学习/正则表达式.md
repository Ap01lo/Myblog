#### 正则表达式

> 记于：2020年12月15日
>
> 完成于：更新中

以前在搜索文件还是提取信息时，总是需要匹配具体的文件，在文件批量处理或者是爬虫的信息抓取，不管是文件还是文件内容，对我来说总有些难度，但是自从了解了正则表达式，才发现这东西可以解决我的需求。

在这里记一下笔记。

##### 简介

正则表达式(Regex)就是使用一堆通配符来匹配你期望的字符串，然后对他们进行替换修改等操作。具体的语法包括选择、数量限定、与匹配等部分。

构造正则表达式的方式与数学表达式的方法一样，都是用多元的字符与运算符将小的表达式合在一起创建更大的表达式，正则表达式表达式的组件可以是单个字符、字符集合、字符范围、字符间的选择或者是所有这些元件的任意组合。

基本元素：普通字符（例如字符a-z）、特殊字符（成为元字符）

##### 普通字符

| 字符   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| [ABC]  | `字符是任意的，不分大小写` 在指定字符串中匹配[]中的所有字符，比如[aBe]就是在字符串中匹配所有的a、B、e字母 |
| [^ABC] | 同上，取反，就是匹配除了[]中的字符的所有字符（有点绕）       |
| [A-Z]  | 表示一个区间，匹配A-Z的所有大写字母，同理[A-H]、[a-z]，注意字母大小写类型要相同 |
| [\s\S] | 匹配所有字符。其中 \s 是匹配所有空白的符号，\S 是匹配所有的非空白符，都包括换行 |
| [\w]   | 匹配字母、数字、下划线。等价于[A-Za-z_]                      |

##### 非打印字符

某些与上面的有重复

| 字符 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| \cX  | X是一个代指的控制字符，例如 \cM 匹配一个 Ctrl+M 或者回车。其中X必须为A-Z与a-z之一，否则跟在后面的x无效，\cx等价为\c |
| \f   | 匹配一个换页符。等价于 \cL                                   |
| \n   | 匹配一个换行符。等价于 \cJ                                   |
| \r   | 匹配一个回车符。等价于 \cM                                   |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。Unicode正则表达式会匹配全角空格。等价于[\f\n\r\t\v] |
| \S   | 匹配任何非空白字符。等价于[\^\\f\n\r\t\v]                    |
| \t   | 匹配一个制表符。等价于 \cL                                   |
| \v   | 匹配一个垂直制表符。等价于 \ck                               |

##### 特殊字符

特殊字符就是拥有特殊含义的字符，比如常用的*、？、$等等，另外的，如果需要匹配这些特殊字符，就**需要进行转译**。

| 字符 | 描述                                             |
| ---- | ------------------------------------------------ |
| \$   | 匹配字符串的结尾位置                             |
| ()   | 标记一个子表达式的开始与结束位置                 |
| *    | 匹配前面的子表达式零次或者多次                   |
| +    | 匹配前面的子表达式一次或者多次                   |
| .    | 匹配除了换行符 \n 之外的任何单字符               |
| [    | 标记一个中括号表达式的开始                       |
| ？   | 匹配前面的子表达式零次或者一次，或者非贪婪限定符 |
| \    | 转译                                             |
| ^    | 匹配字符串的开始位置（在方括号中使用表示取反）   |
| {    | 标记限定表达式的开始                             |
| \|   | 指明两项选择之间的一个选择                       |

##### 限定符

限定符用来限制匹配的字符的次数，有6种

| 字符  | 描述        |
| ----- | ----------- |
| *     | 0次或多次   |
| +     | 1次或多次   |
| ？    | 0次或1次    |
| {n}   | n次         |
| {n,}  | 至少匹配n次 |
| {n,m} | 匹配n至m次  |

例子：

```regex
匹配一个正整数，[1-9]限制第一个数字不是0，[0-9]*限制后面有任意个数字
/[1-9][0-9]*/
```

> 表示范围限制的用[]，表示次数限制的用{}

+ /\[1-9]\[0-9]?/表示匹配数字1-99

***与+都是贪婪的，他们会匹配尽可能多的字符串，在他们后面加上？可以实现最小匹配或者非贪婪**

> 贪婪与非贪婪：
>
> 贪婪是指，匹配时匹配最长的字符串。下述匹配都服从贪婪原则：
>
> +、？、*、{n}、{n,}、{n,m}
>
> 在html的语句 
>
> ```html
> <h1>hhh</h1>
> ```
>
> 中，使用 /<.*>/ 则会匹配到上面的所有内容，如果使用 /<.*?>/，就会使其成为非贪婪的，只会匹配到 第一个\<h1>

##### 定位符

| 字符 | 描述                     |
| ---- | ------------------------ |
| \^   | 匹配输入字符串开始的位置 |
| \$   | 匹配字符串结尾的位置     |
| \b   | 匹配一个单词边界         |
| \B   | 匹配一个非单词边界       |

**注意：不能将限定符与定位符一起用**

```Re
# 匹配单词尾部的hhha
/hhha\b/ 
# 匹配单词首部的hha
/\bhha/
# 匹配单词中间的hhhhha
/\Bhhhhha/
```

如上，\b的位置决定着匹配字符在单词的开头还是结尾，但是\B不影响



##### 选择

使用 `（）` 将所有的选择项括起来，相邻的选择项之间使用 `|` 分割

`()` 表示捕获分组，会把每个分组里的匹配的值保存起来，多个匹配值可以通过数字n来查看（n是一个数字，表示第n个捕获组的内容）

